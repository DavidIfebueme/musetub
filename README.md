# musetub

## overview

musetub is an agentic, pay-per-second streaming lab that stitches arc testnet usdc, circle developer wallets, and an x402 gateway into one experience. viewers prepay for ten-second chunks, creators earn 90%, and the whole stack surfaces owed/settled accounting so you can explain why a stream feels ahead or behind.

## system architecture

- **backend (fastapi + uv)**: handles auth, uploads, content metadata, streaming, payments, wallets, and dashboards. it clocks prepaid credits, submits circle contract executions, polls arc rpc, and returns x402 headers. async sqlalchemy + alembic drive the data layer, redis caches metadata, and httpx talks to arc.
- **frontend (react + vite)**: renders the paywall, video player, dashboards, and creator studio. it polls `/stream` every ten seconds while playing, handles 402 responses, shows arc block heights, and surfaces circle tx error_reason/error_details.
- **foundry contracts**: `ContentEscrow.sol` holds usdc, `MockUSDC3009.sol` is the test double. creators withdraw from escrow via `withdrawCreator()`, and stream payments hit `streamWithAuthorization`.
- **gateway sidecar**: node service that helps with ipfs metadata uploads and answers x402 payment challenges with sidecar-friendly payloads.
- **infra (docker compose)**: postgres, redis, ipfs, and the gateway sidecar can all run from `docker compose up -d`, keeping the local dev loop close to production wiring.

## prepaid streaming credit model

1. every viewer starts with zero credits. playback calls `POST /content/{id}/stream` once every ten seconds. each call decrements `stream_credits.seconds_remaining`, increments the viewer channel’s `total_seconds_streamed`, and bumps `payment_channels.total_amount_owed`. when credit hits zero, the endpoint replies with `402 payment required` plus x402 headers describing what to pay.
2. to top up the frontend calls `POST /content/{id}/pay`. that request: (a) increments `stream_credits.seconds_remaining` by ten, (b) records a `Settlement` row for observability (amount = price_per_second * 10), and (c) when arc/circle are configured, submits a circle contract execution transaction to call `streamWithAuthorization(...)` on the escrow. the transaction pulls usdc via `receiveWithAuthorization`, credits `creatorBalances[creator]` (90%), and bumps `platformBalance` (10%), then returns a circle tx id stored in the settlement.
3. playback only resumes once credits are available. a `402` pauses the video and shows the paywall so users can refill, keeping billing predictable and avoiding surprise tolls mid-playback.

## dashboards explained (owed vs settled)

### owed
- derived from `payment_channels.total_amount_owed` on the viewer side and from `settlements` on the creator side.
- it captures how much service has been consumed (what the viewer streamed, what the creator is owed based on ticks).
- it is updated immediately on every `/stream` call (ten-second chunks).
- owed can temporarily exceed settled when streaming is ahead of the `/pay` confirmation; this resolves once the next pay request (and its circle tx) finishes.

### settled
- on the viewer side this is `payment_channels.total_amount_settled`; creators read the same numbers through their settlement rows.
- it represents how much has been prepaid and recorded in `settlements` (generated by `/pay`).
- settled only increases when the chunk is written to the database, so there can be a lag while the backend waits for circle or arc before storing the on-chain tx hash.

### what to do when numbers differ
- owed > settled: playback is moving faster than `/pay` can record; wait for the payment to finish or rerun the pay request.
- settled > owed: you bought future time (common right after a `/pay`). the system will burn through the prepaid settlement during future `/stream` calls or when a creator withdraw happens.

## x402 payment flow

- the api returns `402 payment required` plus an `accepts` list describing network, token, amount, seller, and timeout.
- the gateway sidecar reads those headers and displays the x402 modal, letting users confirm payment data before returning to the frontend.
- the `payment-response` header tells the browser where to post the proof-of-payment callback after the sidecar finishes the handshake.
- while this demo currently pauses the video on 402, the same headers could be used to auto-submit payments or plug in custom wallets.

## circle + arc + escrow (live vs simulated)

- **simulated mode**: when circle or arc env vars are missing the backend fabricates tx ids (e.g., `simulated:{uuid}`) but still writes to postgres so dashboards stay interactive. no usdc moves on-chain.
- **live mode**:
  - `/content/{id}/pay` signs erc-3009 typed data (via circle developer wallets) and submits a contract execution to call `streamWithAuthorization` on `ContentEscrow.sol`, pulling usdc from the viewer wallet and updating `creatorBalances`/`platformBalance`.
  - creators call `/creators/withdraw` to run `withdrawCreator()` via circle. before submitting the tx the backend issues an `eth_call` to read `creatorBalances(creator)`; if the balance is zero it returns a clear 400 instead of wasting gas estimation.
  - use `GET /wallets/transactions/{tx_id}` to inspect tx state. the response surfaces `state`, `tx_hash`, `error_reason`, and `error_details` so the creator studio can show precise failures like insufficient gas or `NothingToWithdraw()`.

## agentic pricing engine

- uploads begin with structured metadata (duration, resolution, bitrate tier, engagement intent, and optional engagement policies).
- deterministic heuristics combine that metadata with creator reputation to suggest a per-second price; gemini is only used to craft a human-friendly explanation and is cached (redis/postgres) so it stays within the free tier.
- if a deal fits policy bounds it auto-accepts via a `BulkRateAgreement`; otherwise the user agent submits a counteroffer and gemini summarizes the outcome.

## smart contracts reference

- `contracts/src/ContentEscrow.sol`
  - `streamWithAuthorization(...)` calls usdc’s `receiveWithAuthorization` and updates internal accounting (90% creator, 10% platform).
  - `withdrawCreator()` moves the stored creator balance to the creator wallet and reverts with `NothingToWithdraw()` when the balance is zero (hence the backend’s pre-check).
  - `withdrawPlatform()` lets the platform pull the 10% fee.
- `contracts/src/MockUSDC3009.sol` is the local test double for usdc’s erc-3009 interface and is used by backend tests.

## local development steps

1. **env setup**
   - copy `backend/.env.example` to `backend/.env` and fill in database/redis urls, ipfs endpoints, jwt secret + algo, gemini api key, circle api key + entity secret + wallet set id, arc rpc url + chain id, usdc + escrow addresses, x402 config, and gateway urls.

2. **docker infra**
   - run `docker compose up -d` from the repo root to start postgres, redis, ipfs, and the gateway sidecar.
   - postgres listens on `localhost:5433`, redis on `6380`, ipfs api on `5001`, and the gateway sidecar on `4010`.

3. **backend**
   - install uv (if needed): `curl -LsSf https://astral.sh/uv/install.sh | sh`
   - `cd backend`
   - `uv sync`
   - `uv run alembic upgrade head`
   - `uv run uvicorn app.main:app --reload --host 0.0.0.0 --port 8000`
   - tests: `uv run pytest -q`

4. **frontend**
   - `cd frontend`
   - `npm install`
   - `npm run dev`
   - tests: `npm test`

5. **gateway sidecar**
   - it runs automatically in docker compose, reads `backend/.env`, answers x402 challenges on `localhost:4010`, and proxies ipfs uploads.

6. **debugging hints**
   - inspect circle txs with `GET /wallets/transactions/{tx_id}` to see `error_reason`/`error_details`.
   - run the creator studio withdraw flow while looking at the response to catch precise failure messages (insufficient gas, nothing to withdraw, etc.).
   - if `owed` outpaces `settled`, trigger another `/content/{id}/pay` to flush the pending ticks.

refer to `TASKS.md` for future experiments (creator bundles, smarter agentic negotiation, richer ux).
